const flatten=(t,e,i)=>t.reduce(((t,r)=>(BinaryArray.isBinaryArray(r)?t.push(...i(r,e)):t.push(r),t)),[]);export class BinaryArray{left=[void 0];right=[];constructor(t=[]){this.init(t)}static isBinaryArray(t){return t instanceof BinaryArray}static from(t){if(void 0!==t.length){const e=void 0!==t[0]?t:Array.from(t);return new BinaryArray([...e])}}static from(t){if(void 0!==t.length){const e=void 0!==t[0]?t:Array.from(t);return new BinaryArray([...e])}}static of(...t){return new BinaryArray(t)}get offsetLeft(){return-1*(this.left.length-1)}get offsetRight(){return this.right.length}get size(){return this.left.length+this.right.length-1}get length(){return this.left.length+this.right.length-1}get first(){return this.get(0)}get last(){return this.get(this.length-1)}get pivot(){return this.right[0]}_delete(t){if(1===this.length)return this.left=[void 0],void(this.right=[]);-1===t&&this.left.length>0?this.left.length--:1===t&&this.right.length>0&&this.right.length--}abs(t){return t<0?-1*t:t}init(t){t&&!Array.isArray(t)&&"function"==typeof t[Symbol.iterator]&&(t=[...t]),this.length&&this.clear();const e=Math.floor(t.length/2);for(let i=e-1;i>=0;i--)this._addToLeft(t[i]);for(let i=e;i<t.length;i++)this._addToRight(t[i])}get(t){const e=t+this.offsetLeft,i=this.abs(e);return e>=0?this.right[i]:this.left[i]}clear(){this.right=[],this.left=[void 0]}_addToLeft(t){this.left.push(t)}_addToRight(t){this.right.push(t)}_removeFromLeft(){this.length&&this._delete(-1)}_removeFromRight(){this.length&&this._delete(1)}vectorIndexOf(t){const e=t+this.offsetLeft;return e<0?[-1*e,-1]:[e,1]}set(t,e){const[i,r]=this.vectorIndexOf(t);return r>=0?this.right[i]=e:this.left[i]=e}[Symbol.iterator]=function*(){for(let t=0;t<this.length;t++)yield this.get(t)};toArray(){return[...this]}at(t){return t<0?this.get(this.length+t):this.get(t)}push(...t){for(let e=0;e<t.length;e++)this._addToRight(t[e]);return this.length}unshift(...t){for(let e=t.length-1;e>=0;e--)this._addToLeft(t[e]);return this.length}pop(){0===this.offsetRight&&this.balance();const t=this.last;return this._removeFromRight(),t}shift(){0===this.offsetLeft&&this.balance();const t=this.first;return this._removeFromLeft(),t}slice(t,e=this.length){const i=[];for(let r=t;r<e;r++)i.push(this.get(r));return new BinaryArray(i)}splice(t,e=0,...i){const r=[];if(this.offsetLeft+t>0){const h=this.length-t-e;if(this.rotateRight(h),e>0)for(let t=0;t<e;t++)r.push(this.pop());this.push(...i);for(let t=0;t<h;t++)this.push(this.shift())}else{if(this.rotateLeft(t),e>0)for(let t=0;t<e;t++)r.push(this.shift());this.unshift(...i);for(let e=0;e<t;e++)this.unshift(this.pop())}return r}indexOf(t){for(let e=0;e<this.length;e++)if(this.get(e)===t)return e;return-1}lastIndexOf(t){for(let e=this.length-1;e>=0;e--)if(this.get(e)===t)return e;return-1}includes(t){for(let e=0;e<this.length;e++)if(this.get(e)===t)return!0;return!1}find(t){for(let e=0;e<this.length;e++){const i=this.get(e);if(t(i,e,this))return i}}some(t){for(let e=0;e<this.length;e++)if(t(this.get(e),e,this))return!0;return!1}every(t){for(let e=0;e<this.length;e++)if(!t(this.get(e),e,this))return!1;return!0}findIndex(t){for(let e=0;e<this.length;e++){if(t(this.get(e),e,this))return e}return-1}map(t){const e=new BinaryArray,i=Math.floor(this.length/2);for(let r=i-1;r>=0;r--)e._addToLeft(t(this.get(r),r,this));for(let r=i;r<this.length;r++)e._addToRight(t(this.get(r),r,this));return e}mapMut(t){for(let e=0;e<this.length;e++)this.set(e,t(this.get(e),e,this));return this}forEach(t){for(let e=0;e<this.length;e++)t(this.get(e),e,this)}reduce(t,e){for(let i=0;i<this.length;i++)e=t(e,this.get(i),i,this);return e}reduceRight(t,e){for(let i=this.length-1;i>=0;i--)e=t(e,this.get(i),i,this);return e}filter(t){const e=[];for(let i=0;i<this.length;i++){const r=this.get(i);t(r,i,this)&&e.push(r)}return new BinaryArray(e)}reverse(){if(this.length<=2){if(1===this.length)return this;const t=this.get(0);return this.set(0,this.get(1)),this.set(1,t),this}const t=this.left,e=this.right;return e.unshift(t.shift()),this.left=e,this.right=t,this}reverseCopy(){const t=new BinaryArray(this);return t.reverse(),t}sort(t){return new BinaryArray(this.toArray().sort(t))}join(t=","){let e="";for(let i=0;i<this.length-1;i++)e+=this.get(i)+t;return e+=this.get(this.length-1),e}concat(t){return new BinaryArray([...this,...t])}flat(t=1){const e=t===1/0?i=>flatten(i,t,e):(t,i)=>-1===--i?t:flatten(t,i,e);return new BinaryArray(e(this,t))}flatten(t){return new BinaryArray(this.reduce(((e,i,r,h)=>(BinaryArray.isBinaryArray(i)?i.forEach((i=>{e.push(t(i))})):e.push(t(i,r,h)),e)),[]))}addTo(t,e){if(t>=this.length)for(let e=this.length;e<=t;e++)this._addToRight(void 0);const[i,r]=this.vectorIndexOf(t);return r>=0?this.right[i]=e:this.left[i]=e,this.length}addAt(t,...e){if(this.offsetLeft+t>0){const i=this.length-t;this.rotateRight(i),this.push(...e);for(let t=0;t<i;t++)this.push(this.shift())}else{this.rotateLeft(t),this.unshift(...e);for(let e=0;e<t;e++)this.unshift(this.pop())}}removeFrom(t,e){const i=this.length-t;if(e=Math.min(i,e),this.offsetLeft+t>0){this.rotateRight(i);for(let t=0;t<e;t++)this.pop();for(let t=0;t<i;t++)this.push(this.shift())}else{this.rotateLeft(t);for(let t=0;t<e;t++)this.shift();for(let e=0;e<t;e++)this.unshift(this.pop())}}removeFromCopy(t,e){const i=new BinaryArray(this);return i.removeFrom(t,e),i}rotateLeft(t=1){t%=this.length;for(let e=0;e<t;e++)0===this.offsetLeft&&this.balance(),this._addToRight(this.first),this._removeFromLeft()}rotateRight(t=1){t%=this.length;for(let e=0;e<t;e++)0===this.offsetRight&&this.balance(),this._addToLeft(this.last),this._removeFromRight()}rotate(t=1,e=1){1===e?this.rotateRight(t):this.rotateLeft(t)}rotateCopy(t=1,e=1){const i=new BinaryArray(this);return 1===e?i.rotateRight(t):i.rotateLeft(t),i}balance(){if(this.offsetRight+this.offsetLeft===0)return;const t=this.toArray();return this.clear(),this.init(t)}}